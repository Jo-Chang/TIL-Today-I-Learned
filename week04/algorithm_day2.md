# 시간 복잡도

- 계산 복잡도 이론에서 시간 복잡도는 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계를 가리킴.
- 단순하게는 알고리즘의 수행 시간을 의미
- 빅오 표기법
  - 입력 n 이 무한대로 커진다고 가정할 때 시간 복잡도를 간단히 표시하는 것
  - 최고차항만 남기고 계수와 상수를 제거
  - $O(1) < O(\log N) < O(N) < O(N\log N) < O(N^2) < O(2^N) < O(n!)$
    - $O(1)$ : 단순 계산
    - $O(\log N)$: 크기 N인 리스트를 반절씩 순회 / 탐색
    - $O(N)$: 크기 N인 리스트 순회
    - $O(\log N)$: 크기 N인 리스트를 반절씩 탐색 및 순회
    - $O(N^2)$: 크기 M, N인 2중 리스트를 순회
    - $O(2^N)$: 크기 N인 집합의 부분 집합
    - $O(N!)$: 크기 N인 리스트의 순열

# 리스트

- 배열
  - 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조
  - 인덱스를 통해 데이터에 빠르게 접근
  - 배열의 길이는 변경 불가능, 길이를 변경하고 싶다면 새로 생성
  - 데이터 타입 고정
- 연결 리스트
  - 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료 구조
  - 맨 처음 노드부터 순차적으로 탐색
  - 길이 자유롭게 변경 가능, 삽입 / 삭제 편리
  - 다양한 데이터 타입 저장
  - 데이터가 메모리에 연속적으로 저장되지 않음
- Python의 리스트
  - `.append(data)`: 리스트 맨 끝에 data 삽입
  - `.pop(index)`: 리스트 내의 특정 인덱스의 원소를 삭제 및 반환
  - `.count(n)`: 리스트에서 n의 개수 반환
  - `.index(n)`: 리스트에서 처음으로 n이 등장하는 인덱스 반환
  - `.sort()`: 리스트를 오름차순으로 정렬, `reverse=True` 옵션을 통해 내림차순 정렬 가능
  - `.reverse()`: 리스트를 거꾸로 뒤집기
- List Comprehension
  - 리스트를 생성하는 간단한 방법
  - ex) `[i for i in range(5)]`

# 2일차 과제

```python
# pr01. 9085: 더하기
T = int(input())
for _ in range(T):
    N = int(input())
    print(sum(list(map(int, input().split()))))
```

- 숫자를 리스트로 담아 리스트 내의 합을 구하는 방식으로 코드를 작성하였다.

```python
# pr02. 10824: 네 수
a, b, c, d = input().split()
print(int(a+b)+int(c+d))
```

- 문자열로 두 숫자끼리 이은 후 정수형으로 변환하여 더하였다.

```python
# pr03. 3009: 네 번째 점
rect = []
x = []
y = []
for i in range(3):
    a, b = map(int, input().split())
    x.append(a)
    y.append(b)
    rect.append([a, b])

for i in x:
    for j in y:
        if [i, j] not in rect:
            print(i, j)
            break
```

- 리스트 형식으로 좌표들을 저장하고, x좌표와 y좌표를 따로 리스트에 저장하였다. 그 후 좌표 리스트를 순회하며 다른 한 점을 찾았다.
- 다른 실습 조원들 중, 사각형의 길이를 통해 작성한 코드가 있었는데, 반복문을 사용하지 않는 점에서 되게 인상적이었다.

```python
# pr04. 10952: A+B-5
while True:
    a, b = map(int, input().split())
    if a == 0 and b == 0:
        break
    print(a+b)
```

- while 문을 통해 무한 루프를 걸고, 입력으로 0, 0이 들어오면 반복을 종료시키도록 코드를 작성하였다.

```python
# pr05. 1110: 더하기 사이클
N = input()
if len(N) < 2:
    N = '0' + N
new_num = N[-1] + str(sum(list(map(int, N))))[-1]
cnt = 1
while new_num != N:
    new_num = new_num[-1] + str(sum(list(map(int, new_num))))[-1]
    cnt += 1
print(cnt)
```

- 이 문제 같은 경우 숫자를 문자열로 취급하여 풀이하였다. 이 과정에서 형 변환이 많이 일어나서 엄청 좋은 코드라고 생각되지는 않는다.
- 다른 조원의 풀이 중, 문자열로 취급하지 않고 몫과 나머지를 활용하여 작성한 코드가 있었는데, 생각만 하다가 시도하지 않았던 풀이 방식으로 코드를 작성해서 인상적이었다.
