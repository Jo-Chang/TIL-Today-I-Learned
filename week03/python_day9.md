# 클래스

- 클래스 속성(attribute)
  - 한 클래스의 모든 인스턴스라도 똑같은 값을 가지는 속성
  - 클래서 선언 내부에서 정의
  - `<classname>.<name>`으로 접근 및 할당
- 클래스 메서드
  - 클래스가 사용할 메서드
  - `@classmethod` 데코레이터를 사용하여 정의
    - 데코레이터 : 함수를 어떤 함수로 꾸며 새로운 기능 부여
  - 호출 시 첫 번째 인자로 `cls` 전달
- 스태틱 메서드
  - 인스턴스나 클래스를 사용하지 않는 메서드
  - `@staticmethod` 데코레이터를 사용하여 정의
  - 호출 시 어떠한 인자도 전달되지 않음 ( 클래스 및 인스턴스 정보에 접근 및 수정 불가)
- 인스턴스와 클래스 간의 이름공간(namespace)
  - 클래스를 정의하면 클래스와 해당하는 이름공간 생성
  - 인스턴스를 만들면 인스턴스 객체가 생성되고 이름공간 생성
  - 인스턴스에서 특정 속성을 접근할 때, 인스턴스 → 클래스 순으로 탐색

# 상속

- 두 클래스 사이 부모-자식 관계를 정립하는 것.
- 부모에 정의된 속성이나 메서드를 활용하거나 오버라이딩(재정의) 하여 활용 가능
- 코드의 재사용성을 높이고, 클래스 간 계층적 관계를 활용
- python의 모든 클래스는 object를 상속 받음
- 상속 관련 메서드
  - `super()`: 자식 클래스에서 부모 클래스를 사용하고 싶을 경우.

# Python 추가 문법

- 조건표현식
  - `<expression이 true 일 때 값> if <expression> else <expression이 false 일 때 값>`
- `enumerate(iterable, start=0)`
  - 인덱스와 객체를 쌍으로 담은 열거형 객체 `(index, value)` 형태 반환
  - `start` 값이 1이라면 인덱스는 1부터 시작
- List Comprehension
  - 표현식과 제어문을 통해 특정한 값을 가진 리스트를 간결하게 생성하는 방법
- Dictionary Comprehension
  - list comprehension과 비슷한 방식으로 딕셔너리를 간결하게 생성하는 방법
  - ex) `{x: x**3 for x in range(1, 4)}`
- lambda 표현식
  - lambda 함수
    - 표현식을 계산한 결과값을 반환하는 함수
    - 이름이 없는 함수, 익명함수로 불림.
  - 특징
    - return 문을 가질 수 없음
    - 간편 조건문 외 조건문이나 반복문을 가질 수 없음
  - 장점
    - 함수를 정의해 사용하는 것 보다 간결하게 사용
    - def를 사용할 수 없는 곳에서도 사용 가능
  - `lambda x: (x와 관련된 계산식)`
    - 입력 : x
    - 출력 : x와 관련된 계산식

# Type annotation

- 동적 언어 python에서 각 변수 / 함수 마다 Type 에 대한 설명을 덧붙이는 것
- IDE에서 경고를 확인. 코드 작성에서 도움을 받을 수 있음
- 정적 타입이 되는 것은 아님.

# Positional-only parameters

- 함수를 정의할 때 어떻게 호출해야 할 지 지정
- ex) `def f(a, b, /, c, d, *, e, f)`
  - a, b 는 위치만 호출 가능
  - c, d 는 위치 및 키워드 모두 호출 가능
  - e, f 는 키워드만 호출 가능
